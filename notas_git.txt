git -> sistema de control de versiones
	Solamente dejar claro guardar los cambios, quién los hizo y poder volver a ellos en el pasado
	
git init -> empezar en una carpeta tu repositorio
git add biografía.txt -> añadir un archivo
git commit -m 'version 1' -> envía los cambios del archivo a la base de datos con un mensaje "version 1"
	-am -> hacer commit a los archivos modificados QUE SE HAYAN AGREGADO PREVIAMENTE
git add . -> agregar todos los archivos que hayan cambiado en la carpeta en la que estamos en ese momento
git status -> checar el estado de la base de datos de cambios
git show -> mostrar todos los cambios históricos hechos
git log biografía -> muestra los cambios históricos de un archivo
git push -> enviar a un repositorio remoto

Ramificación -> Puedes crear ramas en tu proyecto, lo que te permite trabajar en diferentes características o aspectos del mismo sin afectar el trabajo de los demás

rm vs rm --cached -> significa que está todavía en la memoria ram (en el caché), todavía no guardado en la base de datos 
	Util por si nos equivocamos
	
El comando git reset es una herramienta poderosa que te permite deshacer o revertir cambios en tu repositorio de Git. Lo puedes ejecutar de tres maneras diferentes, con las líneas de comando --soft, --mixed y --hard.

Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.
	
    git reset --soft: Borra el historial y los registros de Git de commits anteriores, pero guarda los cambios en Staging para aplicar las últimas actualizaciones a un nuevo commit.
    git reset --hard: Deshace todo, absolutamente todo. Toda la información de los commits y del área de staging se elimina del historial.
    git reset --mixed: Borra todo, exactamente todo. Toda la información de los commits y del área de staging se elimina del historial.
    git reset HEAD: El comando git reset saca archivos del área de staging sin borrarlos ni realizar otras acciones. Esto impide que los últimos cambios en estos archivos se envíen al último commit. Podemos incluirlos de nuevo en staging con git add si cambiamos de opinión.
	git reset HEAD es un comando que te permite revertir los cambios que ya habías preparado para subir, y moverlos de vuelta a tu proyecto. Con este comando puedes cancelar los cambios que ya habías agregado, para que puedas revisarlos, modificarlos o deshacerlos antes de confirmarlos con un commit.
	
Por otro lado, git rm es un comando que nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Para recuperar el archivo eliminado, necesitamos retroceder en la historia del proyecto, recuperar el último commit y obtener la última confirmación antes de la eliminación del archivo.
	
    git rm --cached: Elimina archivos del repositorio local y del área de staging, pero los mantiene en el disco duro. Deja de trackear el historial de cambios de estos archivos, por lo que quedan en estado untracked.
    git rm --force: Elimina los archivos de Git y del disco duro. Git guarda todo, por lo que podemos recuperar archivos eliminados si es necesario (empleando comandos avanzados).

##### Para trabajar con servidores remotos #####
git clone url -> con el link, traemos los archivos a nuestra carpeta
	se trae una copia del master al directorio del trabajo 
	y se crea la base de datos de todos los datos históricos del proyecto en el repositorio local
git push -> mandar los archivos al servidor remoto, después de hacer un commit en el repositorio local
git fetch -> traer una actualización de cambios menores y lo trae al repositorio local pero no lo copia en los archivos
git merge -> para copiar en nuestros archivos, tenemos que fusionar la última versión en el repositorio local con mi versión actual
	Puede o no terminar con la vida de la rama
	Si estamos en una rama y hacemos merge del HEAD, unimos al merge con la rama, así que es mejor cambiar primero al master y ahora sí hacer merge
	un merge es un commit, así que hay que ponerle un mensaje
para hacer estos dos procesos al mismo tiempo, se hace un git pull

git branch NOMBRE -> Crea una rama pero no nos cambia automáticamente a ella
git checkout NOMBRE -> Cambia a la rama con ese nombre

##### Llaves públicas y llaves privadas #####

Algoritmo también llamado cifrado asimétrico de un solo camino
Las llaves están vinculadas matemáticamente de tal manera que śolo la llave pŕivada puede abrir la llave pública
Se manda la llave pública para descifrar la llave privada
Con la llave pública se cifra el mensaje que querramos enviar 
Sólo con la llave privada podremos descifrar el mensaje 
